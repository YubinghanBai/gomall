// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: order.sql

package sqlc

import (
	"context"
)

const cancelOrder = `-- name: CancelOrder :exec
UPDATE orders
SET
    status = 'cancelled',
    cancelled_at = NOW(),
    updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) CancelOrder(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, cancelOrder, id)
	return err
}

const countUserOrders = `-- name: CountUserOrders :one
SELECT COUNT(*) FROM orders
WHERE user_id = $1 AND deleted_at IS NULL
`

func (q *Queries) CountUserOrders(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countUserOrders, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOrder = `-- name: CreateOrder :one

INSERT INTO orders (
    order_no,
    user_id,
    total_amount,
    discount_amount,
    shipping_fee,
    pay_amount,
    status,
    payment_status,
    ship_status,
    receiver_name,
    receiver_phone,
    receiver_address,
    receiver_zip_code,
    remark
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
) RETURNING id, order_no, user_id, total_amount, discount_amount, shipping_fee, pay_amount, status, payment_status, ship_status, receiver_name, receiver_phone, receiver_address, receiver_zip_code, remark, paid_at, shipped_at, completed_at, cancelled_at, created_at, updated_at, deleted_at
`

type CreateOrderParams struct {
	OrderNo         string  `db:"order_no" json:"order_no"`
	UserID          int64   `db:"user_id" json:"user_id"`
	TotalAmount     int64   `db:"total_amount" json:"total_amount"`
	DiscountAmount  int64   `db:"discount_amount" json:"discount_amount"`
	ShippingFee     int64   `db:"shipping_fee" json:"shipping_fee"`
	PayAmount       int64   `db:"pay_amount" json:"pay_amount"`
	Status          string  `db:"status" json:"status"`
	PaymentStatus   string  `db:"payment_status" json:"payment_status"`
	ShipStatus      string  `db:"ship_status" json:"ship_status"`
	ReceiverName    string  `db:"receiver_name" json:"receiver_name"`
	ReceiverPhone   string  `db:"receiver_phone" json:"receiver_phone"`
	ReceiverAddress string  `db:"receiver_address" json:"receiver_address"`
	ReceiverZipCode *string `db:"receiver_zip_code" json:"receiver_zip_code"`
	Remark          *string `db:"remark" json:"remark"`
}

// Orders Queries
func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.OrderNo,
		arg.UserID,
		arg.TotalAmount,
		arg.DiscountAmount,
		arg.ShippingFee,
		arg.PayAmount,
		arg.Status,
		arg.PaymentStatus,
		arg.ShipStatus,
		arg.ReceiverName,
		arg.ReceiverPhone,
		arg.ReceiverAddress,
		arg.ReceiverZipCode,
		arg.Remark,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.OrderNo,
		&i.UserID,
		&i.TotalAmount,
		&i.DiscountAmount,
		&i.ShippingFee,
		&i.PayAmount,
		&i.Status,
		&i.PaymentStatus,
		&i.ShipStatus,
		&i.ReceiverName,
		&i.ReceiverPhone,
		&i.ReceiverAddress,
		&i.ReceiverZipCode,
		&i.Remark,
		&i.PaidAt,
		&i.ShippedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createOrderItem = `-- name: CreateOrderItem :one

INSERT INTO order_items (
    order_id,
    product_id,
    product_name,
    product_image,
    quantity,
    unit_price,
    total_price
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, order_id, product_id, product_name, product_image, quantity, unit_price, total_price, created_at, updated_at, deleted_at
`

type CreateOrderItemParams struct {
	OrderID      int64   `db:"order_id" json:"order_id"`
	ProductID    int64   `db:"product_id" json:"product_id"`
	ProductName  string  `db:"product_name" json:"product_name"`
	ProductImage *string `db:"product_image" json:"product_image"`
	Quantity     int32   `db:"quantity" json:"quantity"`
	UnitPrice    int64   `db:"unit_price" json:"unit_price"`
	TotalPrice   int64   `db:"total_price" json:"total_price"`
}

// Order Items Queries
func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) (OrderItem, error) {
	row := q.db.QueryRow(ctx, createOrderItem,
		arg.OrderID,
		arg.ProductID,
		arg.ProductName,
		arg.ProductImage,
		arg.Quantity,
		arg.UnitPrice,
		arg.TotalPrice,
	)
	var i OrderItem
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ProductID,
		&i.ProductName,
		&i.ProductImage,
		&i.Quantity,
		&i.UnitPrice,
		&i.TotalPrice,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getOrderByID = `-- name: GetOrderByID :one
SELECT id, order_no, user_id, total_amount, discount_amount, shipping_fee, pay_amount, status, payment_status, ship_status, receiver_name, receiver_phone, receiver_address, receiver_zip_code, remark, paid_at, shipped_at, completed_at, cancelled_at, created_at, updated_at, deleted_at FROM orders
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetOrderByID(ctx context.Context, id int64) (Order, error) {
	row := q.db.QueryRow(ctx, getOrderByID, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.OrderNo,
		&i.UserID,
		&i.TotalAmount,
		&i.DiscountAmount,
		&i.ShippingFee,
		&i.PayAmount,
		&i.Status,
		&i.PaymentStatus,
		&i.ShipStatus,
		&i.ReceiverName,
		&i.ReceiverPhone,
		&i.ReceiverAddress,
		&i.ReceiverZipCode,
		&i.Remark,
		&i.PaidAt,
		&i.ShippedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getOrderByOrderNo = `-- name: GetOrderByOrderNo :one
SELECT id, order_no, user_id, total_amount, discount_amount, shipping_fee, pay_amount, status, payment_status, ship_status, receiver_name, receiver_phone, receiver_address, receiver_zip_code, remark, paid_at, shipped_at, completed_at, cancelled_at, created_at, updated_at, deleted_at FROM orders
WHERE order_no = $1 AND deleted_at IS NULL
`

func (q *Queries) GetOrderByOrderNo(ctx context.Context, orderNo string) (Order, error) {
	row := q.db.QueryRow(ctx, getOrderByOrderNo, orderNo)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.OrderNo,
		&i.UserID,
		&i.TotalAmount,
		&i.DiscountAmount,
		&i.ShippingFee,
		&i.PayAmount,
		&i.Status,
		&i.PaymentStatus,
		&i.ShipStatus,
		&i.ReceiverName,
		&i.ReceiverPhone,
		&i.ReceiverAddress,
		&i.ReceiverZipCode,
		&i.Remark,
		&i.PaidAt,
		&i.ShippedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getOrderItems = `-- name: GetOrderItems :many
SELECT id, order_id, product_id, product_name, product_image, quantity, unit_price, total_price, created_at, updated_at, deleted_at FROM order_items
WHERE order_id = $1 AND deleted_at IS NULL
ORDER BY id
`

func (q *Queries) GetOrderItems(ctx context.Context, orderID int64) ([]OrderItem, error) {
	rows, err := q.db.Query(ctx, getOrderItems, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OrderItem{}
	for rows.Next() {
		var i OrderItem
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProductID,
			&i.ProductName,
			&i.ProductImage,
			&i.Quantity,
			&i.UnitPrice,
			&i.TotalPrice,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderItemsByIDs = `-- name: GetOrderItemsByIDs :many
SELECT id, order_id, product_id, product_name, product_image, quantity, unit_price, total_price, created_at, updated_at, deleted_at FROM order_items
WHERE order_id = ANY($1::bigint[]) AND deleted_at IS NULL
ORDER BY order_id, id
`

func (q *Queries) GetOrderItemsByIDs(ctx context.Context, dollar_1 []int64) ([]OrderItem, error) {
	rows, err := q.db.Query(ctx, getOrderItemsByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OrderItem{}
	for rows.Next() {
		var i OrderItem
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProductID,
			&i.ProductName,
			&i.ProductImage,
			&i.Quantity,
			&i.UnitPrice,
			&i.TotalPrice,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserOrders = `-- name: ListUserOrders :many
SELECT id, order_no, user_id, total_amount, discount_amount, shipping_fee, pay_amount, status, payment_status, ship_status, receiver_name, receiver_phone, receiver_address, receiver_zip_code, remark, paid_at, shipped_at, completed_at, cancelled_at, created_at, updated_at, deleted_at FROM orders
WHERE user_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListUserOrdersParams struct {
	UserID int64 `db:"user_id" json:"user_id"`
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) ListUserOrders(ctx context.Context, arg ListUserOrdersParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, listUserOrders, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.OrderNo,
			&i.UserID,
			&i.TotalAmount,
			&i.DiscountAmount,
			&i.ShippingFee,
			&i.PayAmount,
			&i.Status,
			&i.PaymentStatus,
			&i.ShipStatus,
			&i.ReceiverName,
			&i.ReceiverPhone,
			&i.ReceiverAddress,
			&i.ReceiverZipCode,
			&i.Remark,
			&i.PaidAt,
			&i.ShippedAt,
			&i.CompletedAt,
			&i.CancelledAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrderPaymentStatus = `-- name: UpdateOrderPaymentStatus :exec
UPDATE orders
SET
    payment_status = $1,
    paid_at = CASE WHEN $1 = 'paid' THEN NOW() ELSE paid_at END,
    updated_at = NOW()
WHERE id = $2 AND deleted_at IS NULL
`

type UpdateOrderPaymentStatusParams struct {
	PaymentStatus string `db:"payment_status" json:"payment_status"`
	ID            int64  `db:"id" json:"id"`
}

func (q *Queries) UpdateOrderPaymentStatus(ctx context.Context, arg UpdateOrderPaymentStatusParams) error {
	_, err := q.db.Exec(ctx, updateOrderPaymentStatus, arg.PaymentStatus, arg.ID)
	return err
}

const updateOrderShipStatus = `-- name: UpdateOrderShipStatus :exec
UPDATE orders
SET
    ship_status = $1,
    shipped_at = CASE WHEN $1 = 'shipped' THEN NOW() ELSE shipped_at END,
    updated_at = NOW()
WHERE id = $2 AND deleted_at IS NULL
`

type UpdateOrderShipStatusParams struct {
	ShipStatus string `db:"ship_status" json:"ship_status"`
	ID         int64  `db:"id" json:"id"`
}

func (q *Queries) UpdateOrderShipStatus(ctx context.Context, arg UpdateOrderShipStatusParams) error {
	_, err := q.db.Exec(ctx, updateOrderShipStatus, arg.ShipStatus, arg.ID)
	return err
}

const updateOrderStatus = `-- name: UpdateOrderStatus :exec
UPDATE orders
SET
    status = $1,
    updated_at = NOW()
WHERE id = $2 AND deleted_at IS NULL
`

type UpdateOrderStatusParams struct {
	Status string `db:"status" json:"status"`
	ID     int64  `db:"id" json:"id"`
}

func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) error {
	_, err := q.db.Exec(ctx, updateOrderStatus, arg.Status, arg.ID)
	return err
}
