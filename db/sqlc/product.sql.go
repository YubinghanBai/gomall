// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: product.sql

package sqlc

import (
	"context"
	"time"
)

const countProducts = `-- name: CountProducts :one
SELECT COUNT(*) FROM products
WHERE deleted_at IS NULL
`

func (q *Queries) CountProducts(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countProducts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (
    name, description, brand, price, origin_price, cost_price,
    stock, low_stock_threshold, category_id, status, is_featured, specifications
) VALUES (
             $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
         )
    RETURNING id, name, description, brand, price, origin_price, cost_price, stock, low_stock_threshold, sales_count, view_count, category_id, status, is_featured, specifications, created_at, updated_at, deleted_at
`

type CreateProductParams struct {
	Name              string  `db:"name" json:"name"`
	Description       *string `db:"description" json:"description"`
	Brand             *string `db:"brand" json:"brand"`
	Price             int64   `db:"price" json:"price"`
	OriginPrice       int64   `db:"origin_price" json:"origin_price"`
	CostPrice         *int64  `db:"cost_price" json:"cost_price"`
	Stock             int32   `db:"stock" json:"stock"`
	LowStockThreshold int32   `db:"low_stock_threshold" json:"low_stock_threshold"`
	CategoryID        int64   `db:"category_id" json:"category_id"`
	Status            string  `db:"status" json:"status"`
	IsFeatured        bool    `db:"is_featured" json:"is_featured"`
	Specifications    []byte  `db:"specifications" json:"specifications"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.Name,
		arg.Description,
		arg.Brand,
		arg.Price,
		arg.OriginPrice,
		arg.CostPrice,
		arg.Stock,
		arg.LowStockThreshold,
		arg.CategoryID,
		arg.Status,
		arg.IsFeatured,
		arg.Specifications,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Brand,
		&i.Price,
		&i.OriginPrice,
		&i.CostPrice,
		&i.Stock,
		&i.LowStockThreshold,
		&i.SalesCount,
		&i.ViewCount,
		&i.CategoryID,
		&i.Status,
		&i.IsFeatured,
		&i.Specifications,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createProductImage = `-- name: CreateProductImage :one

INSERT INTO product_images (
    product_id, image_url, sort, is_main
) VALUES (
             $1, $2, $3, $4
         )
    RETURNING id, product_id, image_url, sort, is_main, created_at, updated_at, deleted_at
`

type CreateProductImageParams struct {
	ProductID int64  `db:"product_id" json:"product_id"`
	ImageUrl  string `db:"image_url" json:"image_url"`
	Sort      *int32 `db:"sort" json:"sort"`
	IsMain    *bool  `db:"is_main" json:"is_main"`
}

// Product Images
func (q *Queries) CreateProductImage(ctx context.Context, arg CreateProductImageParams) (ProductImage, error) {
	row := q.db.QueryRow(ctx, createProductImage,
		arg.ProductID,
		arg.ImageUrl,
		arg.Sort,
		arg.IsMain,
	)
	var i ProductImage
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.ImageUrl,
		&i.Sort,
		&i.IsMain,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const decrementProductStock = `-- name: DecrementProductStock :exec
UPDATE products
SET
    stock = stock - $1,
    updated_at = NOW()
WHERE id = $2
  AND stock >= $1
  AND deleted_at IS NULL
`

type DecrementProductStockParams struct {
	Stock int32 `db:"stock" json:"stock"`
	ID    int64 `db:"id" json:"id"`
}

func (q *Queries) DecrementProductStock(ctx context.Context, arg DecrementProductStockParams) error {
	_, err := q.db.Exec(ctx, decrementProductStock, arg.Stock, arg.ID)
	return err
}

const deleteProduct = `-- name: DeleteProduct :exec
UPDATE products
SET deleted_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteProduct, id)
	return err
}

const deleteProductImage = `-- name: DeleteProductImage :exec
UPDATE product_images
SET deleted_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteProductImage(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteProductImage, id)
	return err
}

const deleteProductImages = `-- name: DeleteProductImages :exec
UPDATE product_images
SET deleted_at = NOW()
WHERE product_id = $1
`

func (q *Queries) DeleteProductImages(ctx context.Context, productID int64) error {
	_, err := q.db.Exec(ctx, deleteProductImages, productID)
	return err
}

const getImagesByProductIDs = `-- name: GetImagesByProductIDs :many
SELECT id, product_id, image_url, sort, is_main, created_at, updated_at, deleted_at FROM product_images
WHERE product_id = ANY($1::bigint[])
  AND deleted_at IS NULL
ORDER BY product_id ASC, sort ASC, id ASC
`

func (q *Queries) GetImagesByProductIDs(ctx context.Context, dollar_1 []int64) ([]ProductImage, error) {
	rows, err := q.db.Query(ctx, getImagesByProductIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductImage{}
	for rows.Next() {
		var i ProductImage
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ImageUrl,
			&i.Sort,
			&i.IsMain,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLowStockProducts = `-- name: GetLowStockProducts :many

SELECT id, name, description, brand, price, origin_price, cost_price, stock, low_stock_threshold, sales_count, view_count, category_id, status, is_featured, specifications, created_at, updated_at, deleted_at FROM products
WHERE stock <= low_stock_threshold
  AND status = 'published'
  AND deleted_at IS NULL
ORDER BY stock ASC
LIMIT $1 OFFSET $2
`

type GetLowStockProductsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

// Stock Management
func (q *Queries) GetLowStockProducts(ctx context.Context, arg GetLowStockProductsParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, getLowStockProducts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Brand,
			&i.Price,
			&i.OriginPrice,
			&i.CostPrice,
			&i.Stock,
			&i.LowStockThreshold,
			&i.SalesCount,
			&i.ViewCount,
			&i.CategoryID,
			&i.Status,
			&i.IsFeatured,
			&i.Specifications,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductByID = `-- name: GetProductByID :one
SELECT id, name, description, brand, price, origin_price, cost_price, stock, low_stock_threshold, sales_count, view_count, category_id, status, is_featured, specifications, created_at, updated_at, deleted_at FROM products
WHERE id = $1 AND deleted_at IS NULL
    LIMIT 1
`

func (q *Queries) GetProductByID(ctx context.Context, id int64) (Product, error) {
	row := q.db.QueryRow(ctx, getProductByID, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Brand,
		&i.Price,
		&i.OriginPrice,
		&i.CostPrice,
		&i.Stock,
		&i.LowStockThreshold,
		&i.SalesCount,
		&i.ViewCount,
		&i.CategoryID,
		&i.Status,
		&i.IsFeatured,
		&i.Specifications,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getProductImages = `-- name: GetProductImages :many
SELECT id, product_id, image_url, sort, is_main, created_at, updated_at, deleted_at FROM product_images
WHERE product_id = $1 AND deleted_at IS NULL
ORDER BY sort ASC, id ASC
`

func (q *Queries) GetProductImages(ctx context.Context, productID int64) ([]ProductImage, error) {
	rows, err := q.db.Query(ctx, getProductImages, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductImage{}
	for rows.Next() {
		var i ProductImage
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ImageUrl,
			&i.Sort,
			&i.IsMain,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductMainImage = `-- name: GetProductMainImage :one
SELECT id, product_id, image_url, sort, is_main, created_at, updated_at, deleted_at FROM product_images
WHERE product_id = $1 AND is_main = TRUE AND deleted_at IS NULL
    LIMIT 1
`

func (q *Queries) GetProductMainImage(ctx context.Context, productID int64) (ProductImage, error) {
	row := q.db.QueryRow(ctx, getProductMainImage, productID)
	var i ProductImage
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.ImageUrl,
		&i.Sort,
		&i.IsMain,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getProductsByIDs = `-- name: GetProductsByIDs :many

SELECT id, name, description, brand, price, origin_price, cost_price, stock, low_stock_threshold, sales_count, view_count, category_id, status, is_featured, specifications, created_at, updated_at, deleted_at FROM products
WHERE id = ANY($1::bigint[])
  AND deleted_at IS NULL
ORDER BY sales_count DESC
`

// Batch Operations
func (q *Queries) GetProductsByIDs(ctx context.Context, dollar_1 []int64) ([]Product, error) {
	rows, err := q.db.Query(ctx, getProductsByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Brand,
			&i.Price,
			&i.OriginPrice,
			&i.CostPrice,
			&i.Stock,
			&i.LowStockThreshold,
			&i.SalesCount,
			&i.ViewCount,
			&i.CategoryID,
			&i.Status,
			&i.IsFeatured,
			&i.Specifications,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementProductSales = `-- name: IncrementProductSales :exec
UPDATE products
SET sales_count = sales_count + $1
WHERE id = $2 AND deleted_at IS NULL
`

type IncrementProductSalesParams struct {
	SalesCount int32 `db:"sales_count" json:"sales_count"`
	ID         int64 `db:"id" json:"id"`
}

func (q *Queries) IncrementProductSales(ctx context.Context, arg IncrementProductSalesParams) error {
	_, err := q.db.Exec(ctx, incrementProductSales, arg.SalesCount, arg.ID)
	return err
}

const incrementProductViews = `-- name: IncrementProductViews :exec
UPDATE products
SET view_count = view_count + 1
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) IncrementProductViews(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, incrementProductViews, id)
	return err
}

const listFeaturedProducts = `-- name: ListFeaturedProducts :many
SELECT id, name, description, brand, price, origin_price, cost_price, stock, low_stock_threshold, sales_count, view_count, category_id, status, is_featured, specifications, created_at, updated_at, deleted_at FROM products
WHERE is_featured = TRUE
  AND status = 'published'
  AND deleted_at IS NULL
ORDER BY sales_count DESC
    LIMIT $1 OFFSET $2
`

type ListFeaturedProductsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) ListFeaturedProducts(ctx context.Context, arg ListFeaturedProductsParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, listFeaturedProducts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Brand,
			&i.Price,
			&i.OriginPrice,
			&i.CostPrice,
			&i.Stock,
			&i.LowStockThreshold,
			&i.SalesCount,
			&i.ViewCount,
			&i.CategoryID,
			&i.Status,
			&i.IsFeatured,
			&i.Specifications,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProducts = `-- name: ListProducts :many
SELECT id, name, description, brand, price, origin_price, cost_price, stock, low_stock_threshold, sales_count, view_count, category_id, status, is_featured, specifications, created_at, updated_at, deleted_at FROM products
WHERE deleted_at IS NULL
  AND ($3::bigint IS NULL OR category_id = $3)
  AND ($4::text IS NULL OR status = $4)
ORDER BY created_at DESC
    LIMIT $1 OFFSET $2
`

type ListProductsParams struct {
	Limit      int32   `db:"limit" json:"limit"`
	Offset     int32   `db:"offset" json:"offset"`
	CategoryID *int64  `db:"category_id" json:"category_id"`
	Status     *string `db:"status" json:"status"`
}

func (q *Queries) ListProducts(ctx context.Context, arg ListProductsParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, listProducts,
		arg.Limit,
		arg.Offset,
		arg.CategoryID,
		arg.Status,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Brand,
			&i.Price,
			&i.OriginPrice,
			&i.CostPrice,
			&i.Stock,
			&i.LowStockThreshold,
			&i.SalesCount,
			&i.ViewCount,
			&i.CategoryID,
			&i.Status,
			&i.IsFeatured,
			&i.Specifications,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsByCategory = `-- name: ListProductsByCategory :many
SELECT id, name, description, brand, price, origin_price, cost_price, stock, low_stock_threshold, sales_count, view_count, category_id, status, is_featured, specifications, created_at, updated_at, deleted_at FROM products
WHERE category_id = $1
  AND status = 'published'
  AND deleted_at IS NULL
ORDER BY sales_count DESC
    LIMIT $2 OFFSET $3
`

type ListProductsByCategoryParams struct {
	CategoryID int64 `db:"category_id" json:"category_id"`
	Limit      int32 `db:"limit" json:"limit"`
	Offset     int32 `db:"offset" json:"offset"`
}

func (q *Queries) ListProductsByCategory(ctx context.Context, arg ListProductsByCategoryParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, listProductsByCategory, arg.CategoryID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Brand,
			&i.Price,
			&i.OriginPrice,
			&i.CostPrice,
			&i.Stock,
			&i.LowStockThreshold,
			&i.SalesCount,
			&i.ViewCount,
			&i.CategoryID,
			&i.Status,
			&i.IsFeatured,
			&i.Specifications,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsByPriceRange = `-- name: ListProductsByPriceRange :many

SELECT id, name, description, brand, price, origin_price, cost_price, stock, low_stock_threshold, sales_count, view_count, category_id, status, is_featured, specifications, created_at, updated_at, deleted_at FROM products
WHERE deleted_at IS NULL
  AND status = 'published'
  AND price BETWEEN $1 AND $2
ORDER BY sales_count DESC
LIMIT $3 OFFSET $4
`

type ListProductsByPriceRangeParams struct {
	Price   int64 `db:"price" json:"price"`
	Price_2 int64 `db:"price_2" json:"price_2"`
	Limit   int32 `db:"limit" json:"limit"`
	Offset  int32 `db:"offset" json:"offset"`
}

// Advanced Filtering
func (q *Queries) ListProductsByPriceRange(ctx context.Context, arg ListProductsByPriceRangeParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, listProductsByPriceRange,
		arg.Price,
		arg.Price_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Brand,
			&i.Price,
			&i.OriginPrice,
			&i.CostPrice,
			&i.Stock,
			&i.LowStockThreshold,
			&i.SalesCount,
			&i.ViewCount,
			&i.CategoryID,
			&i.Status,
			&i.IsFeatured,
			&i.Specifications,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProducts = `-- name: SearchProducts :many
SELECT id, name, description, brand, price, origin_price, cost_price, stock, low_stock_threshold, sales_count, view_count, category_id, status, is_featured, specifications, created_at, updated_at, deleted_at FROM products
WHERE deleted_at IS NULL
  AND status = 'published'
  AND (name ILIKE '%' || $1 || '%' OR description ILIKE '%' || $1 || '%')
ORDER BY sales_count DESC
    LIMIT $2 OFFSET $3
`

type SearchProductsParams struct {
	Column1 *string `db:"column_1" json:"column_1"`
	Limit   int32   `db:"limit" json:"limit"`
	Offset  int32   `db:"offset" json:"offset"`
}

func (q *Queries) SearchProducts(ctx context.Context, arg SearchProductsParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, searchProducts, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Brand,
			&i.Price,
			&i.OriginPrice,
			&i.CostPrice,
			&i.Stock,
			&i.LowStockThreshold,
			&i.SalesCount,
			&i.ViewCount,
			&i.CategoryID,
			&i.Status,
			&i.IsFeatured,
			&i.Specifications,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :exec
UPDATE products
SET
    name = COALESCE($1, name),
    description = COALESCE($2, description),
    brand = COALESCE($3, brand),
    price = COALESCE($4, price),
    origin_price = COALESCE($5, origin_price),
    stock = COALESCE($6, stock),
    category_id = COALESCE($7, category_id),
    status = COALESCE($8, status),
    is_featured = COALESCE($9, is_featured),
    updated_at = NOW()
WHERE id = $10 AND deleted_at IS NULL
`

type UpdateProductParams struct {
	Name        *string `db:"name" json:"name"`
	Description *string `db:"description" json:"description"`
	Brand       *string `db:"brand" json:"brand"`
	Price       *int64  `db:"price" json:"price"`
	OriginPrice *int64  `db:"origin_price" json:"origin_price"`
	Stock       *int32  `db:"stock" json:"stock"`
	CategoryID  *int64  `db:"category_id" json:"category_id"`
	Status      *string `db:"status" json:"status"`
	IsFeatured  *bool   `db:"is_featured" json:"is_featured"`
	ID          int64   `db:"id" json:"id"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) error {
	_, err := q.db.Exec(ctx, updateProduct,
		arg.Name,
		arg.Description,
		arg.Brand,
		arg.Price,
		arg.OriginPrice,
		arg.Stock,
		arg.CategoryID,
		arg.Status,
		arg.IsFeatured,
		arg.ID,
	)
	return err
}

const updateProductImage = `-- name: UpdateProductImage :exec
UPDATE product_images
SET
    image_url = COALESCE($1, image_url),
    sort = COALESCE($2, sort),
    is_main = COALESCE($3, is_main),
    updated_at = NOW()
WHERE id = $4 AND deleted_at IS NULL
`

type UpdateProductImageParams struct {
	ImageUrl *string `db:"image_url" json:"image_url"`
	Sort     *int32  `db:"sort" json:"sort"`
	IsMain   *bool   `db:"is_main" json:"is_main"`
	ID       int64   `db:"id" json:"id"`
}

func (q *Queries) UpdateProductImage(ctx context.Context, arg UpdateProductImageParams) error {
	_, err := q.db.Exec(ctx, updateProductImage,
		arg.ImageUrl,
		arg.Sort,
		arg.IsMain,
		arg.ID,
	)
	return err
}

const updateProductStock = `-- name: UpdateProductStock :exec
UPDATE products
SET
    stock = stock + $1,
    updated_at = NOW()
WHERE id = $2 AND deleted_at IS NULL
`

type UpdateProductStockParams struct {
	Stock int32 `db:"stock" json:"stock"`
	ID    int64 `db:"id" json:"id"`
}

func (q *Queries) UpdateProductStock(ctx context.Context, arg UpdateProductStockParams) error {
	_, err := q.db.Exec(ctx, updateProductStock, arg.Stock, arg.ID)
	return err
}

const updateProductStockWithVersion = `-- name: UpdateProductStockWithVersion :one
UPDATE products
SET
    stock = stock + $1,
    updated_at = NOW()
WHERE id = $2
  AND updated_at = $3
  AND deleted_at IS NULL
RETURNING id, name, description, brand, price, origin_price, cost_price, stock, low_stock_threshold, sales_count, view_count, category_id, status, is_featured, specifications, created_at, updated_at, deleted_at
`

type UpdateProductStockWithVersionParams struct {
	Stock     int32     `db:"stock" json:"stock"`
	ID        int64     `db:"id" json:"id"`
	UpdatedAt time.Time `db:"updated_at" json:"updated_at"`
}

func (q *Queries) UpdateProductStockWithVersion(ctx context.Context, arg UpdateProductStockWithVersionParams) (Product, error) {
	row := q.db.QueryRow(ctx, updateProductStockWithVersion, arg.Stock, arg.ID, arg.UpdatedAt)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Brand,
		&i.Price,
		&i.OriginPrice,
		&i.CostPrice,
		&i.Stock,
		&i.LowStockThreshold,
		&i.SalesCount,
		&i.ViewCount,
		&i.CategoryID,
		&i.Status,
		&i.IsFeatured,
		&i.Specifications,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateProductsStatus = `-- name: UpdateProductsStatus :exec
UPDATE products
SET status = $1, updated_at = NOW()
WHERE id = ANY($2::bigint[])
  AND deleted_at IS NULL
`

type UpdateProductsStatusParams struct {
	Status  string  `db:"status" json:"status"`
	Column2 []int64 `db:"column_2" json:"column_2"`
}

func (q *Queries) UpdateProductsStatus(ctx context.Context, arg UpdateProductsStatusParams) error {
	_, err := q.db.Exec(ctx, updateProductsStatus, arg.Status, arg.Column2)
	return err
}
