// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: inventory.sql

package sqlc

import (
	"context"
	"time"
)

const addAvailableStock = `-- name: AddAvailableStock :exec
UPDATE inventory
SET
    available_stock = available_stock + $1,
    version = version + 1,
    updated_at = NOW()
WHERE product_id = $2 AND deleted_at IS NULL
`

type AddAvailableStockParams struct {
	AvailableStock int32 `db:"available_stock" json:"available_stock"`
	ProductID      int64 `db:"product_id" json:"product_id"`
}

func (q *Queries) AddAvailableStock(ctx context.Context, arg AddAvailableStockParams) error {
	_, err := q.db.Exec(ctx, addAvailableStock, arg.AvailableStock, arg.ProductID)
	return err
}

const cancelReservation = `-- name: CancelReservation :exec
UPDATE inventory_reservations
SET
    status = 'cancelled',
    updated_at = NOW()
WHERE order_id = $1 AND status = 'active' AND deleted_at IS NULL
`

func (q *Queries) CancelReservation(ctx context.Context, orderID int64) error {
	_, err := q.db.Exec(ctx, cancelReservation, orderID)
	return err
}

const confirmReservation = `-- name: ConfirmReservation :exec
UPDATE inventory_reservations
SET
    status = 'confirmed',
    updated_at = NOW()
WHERE order_id = $1 AND status = 'active' AND deleted_at IS NULL
`

func (q *Queries) ConfirmReservation(ctx context.Context, orderID int64) error {
	_, err := q.db.Exec(ctx, confirmReservation, orderID)
	return err
}

const countInventories = `-- name: CountInventories :one
SELECT COUNT(*) FROM inventory
WHERE deleted_at IS NULL
`

func (q *Queries) CountInventories(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countInventories)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countInventoryLogsByProductID = `-- name: CountInventoryLogsByProductID :one
SELECT COUNT(*) FROM inventory_logs
WHERE product_id = $1
`

func (q *Queries) CountInventoryLogsByProductID(ctx context.Context, productID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countInventoryLogsByProductID, productID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countLowStockInventories = `-- name: CountLowStockInventories :one
SELECT COUNT(*) FROM inventory
WHERE available_stock <= low_stock_threshold AND deleted_at IS NULL
`

func (q *Queries) CountLowStockInventories(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countLowStockInventories)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createInventory = `-- name: CreateInventory :one

INSERT INTO inventory (
    product_id,
    available_stock,
    reserved_stock,
    low_stock_threshold
) VALUES (
    $1, $2, $3, $4
) RETURNING id, product_id, available_stock, reserved_stock, total_stock, low_stock_threshold, version, created_at, updated_at, deleted_at
`

type CreateInventoryParams struct {
	ProductID         int64  `db:"product_id" json:"product_id"`
	AvailableStock    int32  `db:"available_stock" json:"available_stock"`
	ReservedStock     int32  `db:"reserved_stock" json:"reserved_stock"`
	LowStockThreshold *int32 `db:"low_stock_threshold" json:"low_stock_threshold"`
}

// Inventory Queries
func (q *Queries) CreateInventory(ctx context.Context, arg CreateInventoryParams) (Inventory, error) {
	row := q.db.QueryRow(ctx, createInventory,
		arg.ProductID,
		arg.AvailableStock,
		arg.ReservedStock,
		arg.LowStockThreshold,
	)
	var i Inventory
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.AvailableStock,
		&i.ReservedStock,
		&i.TotalStock,
		&i.LowStockThreshold,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createInventoryLog = `-- name: CreateInventoryLog :one

INSERT INTO inventory_logs (
    product_id,
    order_id,
    change_type,
    quantity_change,
    before_available,
    after_available,
    before_reserved,
    after_reserved,
    reason,
    operator_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, product_id, order_id, change_type, quantity_change, before_available, after_available, before_reserved, after_reserved, reason, operator_id, created_at
`

type CreateInventoryLogParams struct {
	ProductID       int64   `db:"product_id" json:"product_id"`
	OrderID         *int64  `db:"order_id" json:"order_id"`
	ChangeType      string  `db:"change_type" json:"change_type"`
	QuantityChange  int32   `db:"quantity_change" json:"quantity_change"`
	BeforeAvailable int32   `db:"before_available" json:"before_available"`
	AfterAvailable  int32   `db:"after_available" json:"after_available"`
	BeforeReserved  int32   `db:"before_reserved" json:"before_reserved"`
	AfterReserved   int32   `db:"after_reserved" json:"after_reserved"`
	Reason          *string `db:"reason" json:"reason"`
	OperatorID      *int64  `db:"operator_id" json:"operator_id"`
}

// Inventory Logs Queries
func (q *Queries) CreateInventoryLog(ctx context.Context, arg CreateInventoryLogParams) (InventoryLog, error) {
	row := q.db.QueryRow(ctx, createInventoryLog,
		arg.ProductID,
		arg.OrderID,
		arg.ChangeType,
		arg.QuantityChange,
		arg.BeforeAvailable,
		arg.AfterAvailable,
		arg.BeforeReserved,
		arg.AfterReserved,
		arg.Reason,
		arg.OperatorID,
	)
	var i InventoryLog
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.OrderID,
		&i.ChangeType,
		&i.QuantityChange,
		&i.BeforeAvailable,
		&i.AfterAvailable,
		&i.BeforeReserved,
		&i.AfterReserved,
		&i.Reason,
		&i.OperatorID,
		&i.CreatedAt,
	)
	return i, err
}

const createInventoryReservation = `-- name: CreateInventoryReservation :one

INSERT INTO inventory_reservations (
    product_id,
    order_id,
    quantity,
    status,
    expires_at
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, product_id, order_id, quantity, status, expires_at, created_at, updated_at, deleted_at
`

type CreateInventoryReservationParams struct {
	ProductID int64     `db:"product_id" json:"product_id"`
	OrderID   int64     `db:"order_id" json:"order_id"`
	Quantity  int32     `db:"quantity" json:"quantity"`
	Status    *string   `db:"status" json:"status"`
	ExpiresAt time.Time `db:"expires_at" json:"expires_at"`
}

// Inventory Reservations Queries
func (q *Queries) CreateInventoryReservation(ctx context.Context, arg CreateInventoryReservationParams) (InventoryReservation, error) {
	row := q.db.QueryRow(ctx, createInventoryReservation,
		arg.ProductID,
		arg.OrderID,
		arg.Quantity,
		arg.Status,
		arg.ExpiresAt,
	)
	var i InventoryReservation
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.OrderID,
		&i.Quantity,
		&i.Status,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deductReservedStock = `-- name: DeductReservedStock :exec
UPDATE inventory
SET
    reserved_stock = reserved_stock - $1,
    version = version + 1,
    updated_at = NOW()
WHERE product_id = $2
    AND reserved_stock >= $1
    AND version = $3
    AND deleted_at IS NULL
`

type DeductReservedStockParams struct {
	ReservedStock int32 `db:"reserved_stock" json:"reserved_stock"`
	ProductID     int64 `db:"product_id" json:"product_id"`
	Version       int64 `db:"version" json:"version"`
}

func (q *Queries) DeductReservedStock(ctx context.Context, arg DeductReservedStockParams) error {
	_, err := q.db.Exec(ctx, deductReservedStock, arg.ReservedStock, arg.ProductID, arg.Version)
	return err
}

const deleteInventory = `-- name: DeleteInventory :exec
UPDATE inventory
SET
    deleted_at = NOW()
WHERE product_id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeleteInventory(ctx context.Context, productID int64) error {
	_, err := q.db.Exec(ctx, deleteInventory, productID)
	return err
}

const deleteReservation = `-- name: DeleteReservation :exec
UPDATE inventory_reservations
SET
    deleted_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeleteReservation(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteReservation, id)
	return err
}

const getActiveReservationsByProductID = `-- name: GetActiveReservationsByProductID :many
SELECT id, product_id, order_id, quantity, status, expires_at, created_at, updated_at, deleted_at FROM inventory_reservations
WHERE product_id = $1
    AND status = 'active'
    AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) GetActiveReservationsByProductID(ctx context.Context, productID int64) ([]InventoryReservation, error) {
	rows, err := q.db.Query(ctx, getActiveReservationsByProductID, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []InventoryReservation{}
	for rows.Next() {
		var i InventoryReservation
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.OrderID,
			&i.Quantity,
			&i.Status,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpiredReservations = `-- name: GetExpiredReservations :many
SELECT id, product_id, order_id, quantity, status, expires_at, created_at, updated_at, deleted_at FROM inventory_reservations
WHERE status = 'active'
    AND expires_at < NOW()
    AND deleted_at IS NULL
ORDER BY expires_at ASC
LIMIT $1
`

func (q *Queries) GetExpiredReservations(ctx context.Context, limit int32) ([]InventoryReservation, error) {
	rows, err := q.db.Query(ctx, getExpiredReservations, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []InventoryReservation{}
	for rows.Next() {
		var i InventoryReservation
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.OrderID,
			&i.Quantity,
			&i.Status,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInventoryByID = `-- name: GetInventoryByID :one
SELECT id, product_id, available_stock, reserved_stock, total_stock, low_stock_threshold, version, created_at, updated_at, deleted_at FROM inventory
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetInventoryByID(ctx context.Context, id int64) (Inventory, error) {
	row := q.db.QueryRow(ctx, getInventoryByID, id)
	var i Inventory
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.AvailableStock,
		&i.ReservedStock,
		&i.TotalStock,
		&i.LowStockThreshold,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getInventoryByProductID = `-- name: GetInventoryByProductID :one
SELECT id, product_id, available_stock, reserved_stock, total_stock, low_stock_threshold, version, created_at, updated_at, deleted_at FROM inventory
WHERE product_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetInventoryByProductID(ctx context.Context, productID int64) (Inventory, error) {
	row := q.db.QueryRow(ctx, getInventoryByProductID, productID)
	var i Inventory
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.AvailableStock,
		&i.ReservedStock,
		&i.TotalStock,
		&i.LowStockThreshold,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getInventoryLogsByOrderID = `-- name: GetInventoryLogsByOrderID :many
SELECT id, product_id, order_id, change_type, quantity_change, before_available, after_available, before_reserved, after_reserved, reason, operator_id, created_at FROM inventory_logs
WHERE order_id = $1::bigint
ORDER BY created_at DESC
`

func (q *Queries) GetInventoryLogsByOrderID(ctx context.Context, orderID int64) ([]InventoryLog, error) {
	rows, err := q.db.Query(ctx, getInventoryLogsByOrderID, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []InventoryLog{}
	for rows.Next() {
		var i InventoryLog
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.OrderID,
			&i.ChangeType,
			&i.QuantityChange,
			&i.BeforeAvailable,
			&i.AfterAvailable,
			&i.BeforeReserved,
			&i.AfterReserved,
			&i.Reason,
			&i.OperatorID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInventoryLogsByProductID = `-- name: GetInventoryLogsByProductID :many
SELECT id, product_id, order_id, change_type, quantity_change, before_available, after_available, before_reserved, after_reserved, reason, operator_id, created_at FROM inventory_logs
WHERE product_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetInventoryLogsByProductIDParams struct {
	ProductID int64 `db:"product_id" json:"product_id"`
	Limit     int32 `db:"limit" json:"limit"`
	Offset    int32 `db:"offset" json:"offset"`
}

func (q *Queries) GetInventoryLogsByProductID(ctx context.Context, arg GetInventoryLogsByProductIDParams) ([]InventoryLog, error) {
	rows, err := q.db.Query(ctx, getInventoryLogsByProductID, arg.ProductID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []InventoryLog{}
	for rows.Next() {
		var i InventoryLog
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.OrderID,
			&i.ChangeType,
			&i.QuantityChange,
			&i.BeforeAvailable,
			&i.AfterAvailable,
			&i.BeforeReserved,
			&i.AfterReserved,
			&i.Reason,
			&i.OperatorID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInventoryReservationByID = `-- name: GetInventoryReservationByID :one
SELECT id, product_id, order_id, quantity, status, expires_at, created_at, updated_at, deleted_at FROM inventory_reservations
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetInventoryReservationByID(ctx context.Context, id int64) (InventoryReservation, error) {
	row := q.db.QueryRow(ctx, getInventoryReservationByID, id)
	var i InventoryReservation
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.OrderID,
		&i.Quantity,
		&i.Status,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getInventoryReservationByOrderID = `-- name: GetInventoryReservationByOrderID :many
SELECT id, product_id, order_id, quantity, status, expires_at, created_at, updated_at, deleted_at FROM inventory_reservations
WHERE order_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetInventoryReservationByOrderID(ctx context.Context, orderID int64) ([]InventoryReservation, error) {
	rows, err := q.db.Query(ctx, getInventoryReservationByOrderID, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []InventoryReservation{}
	for rows.Next() {
		var i InventoryReservation
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.OrderID,
			&i.Quantity,
			&i.Status,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInventories = `-- name: ListInventories :many
SELECT id, product_id, available_stock, reserved_stock, total_stock, low_stock_threshold, version, created_at, updated_at, deleted_at FROM inventory
WHERE deleted_at IS NULL
ORDER BY id
LIMIT $1 OFFSET $2
`

type ListInventoriesParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) ListInventories(ctx context.Context, arg ListInventoriesParams) ([]Inventory, error) {
	rows, err := q.db.Query(ctx, listInventories, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Inventory{}
	for rows.Next() {
		var i Inventory
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.AvailableStock,
			&i.ReservedStock,
			&i.TotalStock,
			&i.LowStockThreshold,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLowStockInventories = `-- name: ListLowStockInventories :many
SELECT id, product_id, available_stock, reserved_stock, total_stock, low_stock_threshold, version, created_at, updated_at, deleted_at FROM inventory
WHERE available_stock <= low_stock_threshold AND deleted_at IS NULL
ORDER BY available_stock ASC
LIMIT $1 OFFSET $2
`

type ListLowStockInventoriesParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) ListLowStockInventories(ctx context.Context, arg ListLowStockInventoriesParams) ([]Inventory, error) {
	rows, err := q.db.Query(ctx, listLowStockInventories, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Inventory{}
	for rows.Next() {
		var i Inventory
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.AvailableStock,
			&i.ReservedStock,
			&i.TotalStock,
			&i.LowStockThreshold,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const releaseReservedStock = `-- name: ReleaseReservedStock :exec
UPDATE inventory
SET
    available_stock = available_stock + $1,
    reserved_stock = reserved_stock - $1,
    version = version + 1,
    updated_at = NOW()
WHERE product_id = $2
    AND reserved_stock >= $1
    AND version = $3
    AND deleted_at IS NULL
`

type ReleaseReservedStockParams struct {
	AvailableStock int32 `db:"available_stock" json:"available_stock"`
	ProductID      int64 `db:"product_id" json:"product_id"`
	Version        int64 `db:"version" json:"version"`
}

func (q *Queries) ReleaseReservedStock(ctx context.Context, arg ReleaseReservedStockParams) error {
	_, err := q.db.Exec(ctx, releaseReservedStock, arg.AvailableStock, arg.ProductID, arg.Version)
	return err
}

const reserveStock = `-- name: ReserveStock :exec
UPDATE inventory
SET
    available_stock = available_stock - $1,
    reserved_stock = reserved_stock + $1,
    version = version + 1,
    updated_at = NOW()
WHERE product_id = $2
    AND available_stock >= $1
    AND version = $3
    AND deleted_at IS NULL
`

type ReserveStockParams struct {
	AvailableStock int32 `db:"available_stock" json:"available_stock"`
	ProductID      int64 `db:"product_id" json:"product_id"`
	Version        int64 `db:"version" json:"version"`
}

func (q *Queries) ReserveStock(ctx context.Context, arg ReserveStockParams) error {
	_, err := q.db.Exec(ctx, reserveStock, arg.AvailableStock, arg.ProductID, arg.Version)
	return err
}

const updateInventoryStock = `-- name: UpdateInventoryStock :exec
UPDATE inventory
SET
    available_stock = $1,
    reserved_stock = $2,
    version = version + 1,
    updated_at = NOW()
WHERE product_id = $3 AND version = $4 AND deleted_at IS NULL
`

type UpdateInventoryStockParams struct {
	AvailableStock int32 `db:"available_stock" json:"available_stock"`
	ReservedStock  int32 `db:"reserved_stock" json:"reserved_stock"`
	ProductID      int64 `db:"product_id" json:"product_id"`
	Version        int64 `db:"version" json:"version"`
}

func (q *Queries) UpdateInventoryStock(ctx context.Context, arg UpdateInventoryStockParams) error {
	_, err := q.db.Exec(ctx, updateInventoryStock,
		arg.AvailableStock,
		arg.ReservedStock,
		arg.ProductID,
		arg.Version,
	)
	return err
}

const updateLowStockThreshold = `-- name: UpdateLowStockThreshold :exec
UPDATE inventory
SET
    low_stock_threshold = $1,
    updated_at = NOW()
WHERE product_id = $2 AND deleted_at IS NULL
`

type UpdateLowStockThresholdParams struct {
	LowStockThreshold *int32 `db:"low_stock_threshold" json:"low_stock_threshold"`
	ProductID         int64  `db:"product_id" json:"product_id"`
}

func (q *Queries) UpdateLowStockThreshold(ctx context.Context, arg UpdateLowStockThresholdParams) error {
	_, err := q.db.Exec(ctx, updateLowStockThreshold, arg.LowStockThreshold, arg.ProductID)
	return err
}

const updateReservationStatus = `-- name: UpdateReservationStatus :exec
UPDATE inventory_reservations
SET
    status = $1,
    updated_at = NOW()
WHERE id = $2 AND deleted_at IS NULL
`

type UpdateReservationStatusParams struct {
	Status *string `db:"status" json:"status"`
	ID     int64   `db:"id" json:"id"`
}

func (q *Queries) UpdateReservationStatus(ctx context.Context, arg UpdateReservationStatusParams) error {
	_, err := q.db.Exec(ctx, updateReservationStatus, arg.Status, arg.ID)
	return err
}
